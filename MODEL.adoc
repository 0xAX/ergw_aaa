= Abstract Session State Machine =

This document describes the basic building blocks and how they work together to implement
session behaviors. The goal is to have highly formalized, restricted, minimal set of
primitives to describe a FSM that can implement different session behaviors.

NOTE: In the final version, it should be possible to describe the FSM with a DSL that then gets
executed by a driver or compiled into Erlang. Intermediate steps might use Elixir or other
languages.

== Model ==

The session logic is driven by a FSM.

The full FSM describes the *behavior* of a session. States in the FSM are represent a *policy*.
A *policy* is defined by *settings*, *variables* and a initial sequence of *actions*, a list of
*events* it understands, and sequences of *actions* attached to those *events*. *Variables*
can have attached *triggers* that will queue *events* for the current behavior.
*Settings* are used by *adapters* to communicate the policy to the enforcing elements.
*Adapters* are invoked thought *apply_policy* method.

== Work Flow ==

When a state is entered, a sequence of *actions* is executed. A *action* sequence is atomic in the
sense that external events will only be considered after the sequence has finished. The *actions*
have to be side effect free, that means they can not change the current state of the FSM, they
can however queue *events* for the *behavior* to be execute after the current action sequence has
finished.

After the initial sequence of *actions* has finished, all pending *events* that are __understood__ by the
current *policy* are considered in the order of their arrival. Pending *events* that are not understood by
the current *policy* are left in the pending queue to be processed by a later state. A special
*action* to flush the pending queue exists. *Events* can have multiple *action* sequences, each such sequence
has a precondition, only the first *action* sequence witch's that has a matching precondition is executed,
a default or fall-through *action* sequence might exist.

*Event* *actions* are permitted to change the FSM's current state. On FSM state change, the execution
of the current *action* will be terminated and the control will be transferred to the new states
initial *action* sequence.

*Triggers* can be attached to *variables* in a policy. Once a *trigger* is hit, it will send an *event*
to the *behavior*. The behavior of a *trigger* is defined by it's implementation (type).

== Triggers ==

*to be extended and clarified*

Timeout::
  executes a give absolute time, can also be initialized with a relative value
Counter Limit::
  a integer value reaching a certain limit, variations or parameter? could define a hysteresis

others?

== Simple Sample Behavior ==

************************************************
PlantUML can only partly visualize the behavior model.
- Actions on events are currently left out
- Actions with parameters are written as ´Action(Parameter = Value)´
- Events with conditions as ´Event[Conditional Expression]´
************************************************

["plantuml", "sample1.png", "png"]
---------------------------------------------------------------------
[*] --> OffLine
OffLine --> [*] :: ClearSession
OffLine : Sample Action 1
OffLine : Sample Action 2

OffLine --> AuthPending : AuthenticationRequest
AuthPending : RequestAuthentication(NewClass = OnLine)

AuthPending --> OnLine : Authentication-Access-Accept[NewClass == OnLine]
AuthPending --> OffLine : Authentication-Access-Accept[NewClass == OffLine]
AuthPending --> OffLine : Authentication-Access-Denied
AuthPending --> OffLine : Timeout

StopAccounting --> OffLine
StopAccounting --> [*] :: ClearSession

OnLine --> StopAccounting : Timeout
OnLine --> [*] : ClearSession
OnLine : StartAccounting()
---------------------------------------------------------------------

== behavior vs. gen_fsm ==

A behavior is a FSM, so what is difference between a gen_fsm and behavior?

. one file per state
  gen_fsm all in one source file makes complex FSM hard do read and maintain
. selective receive per state
  only events supported by a state are actually read from the mailbox. This could
  be emulated by using a queue on unhandled events in an gen_fsm, but flushing all
  unhandled messages from an mailbox also impacts back pressure in process trying to
  put message into the mailbox
. a behavior never ever blocks
  gen_fsm's have blocking calls, behaviors don't. Using a combination of blocking calls
  that call other processes that try to call into the same fsm again, will deadlock.
. code structure of state implementation is prepared for generation through a DSL